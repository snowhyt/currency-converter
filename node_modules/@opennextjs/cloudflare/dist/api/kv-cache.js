import { IgnorableError, RecoverableError } from "@opennextjs/aws/utils/error.js";
import { getCloudflareContext } from "./cloudflare-context.js";
export const CACHE_ASSET_DIR = "cdn-cgi/_next_cache";
export const STATUS_DELETED = 1;
/**
 * Open Next cache based on cloudflare KV and Assets.
 *
 * Note: The class is instantiated outside of the request context.
 * The cloudflare context and process.env are not initialzed yet
 * when the constructor is called.
 */
class Cache {
    name = "cloudflare-kv";
    async get(key, isFetch) {
        const cfEnv = getCloudflareContext().env;
        const kv = cfEnv.NEXT_CACHE_WORKERS_KV;
        const assets = cfEnv.ASSETS;
        if (!(kv || assets)) {
            throw new IgnorableError(`No KVNamespace nor Fetcher`);
        }
        this.debug(`Get ${key}`);
        try {
            let entry = null;
            if (kv) {
                this.debug(`- From KV`);
                const kvKey = this.getKVKey(key, isFetch);
                entry = await kv.get(kvKey, "json");
                if (entry?.status === STATUS_DELETED) {
                    return null;
                }
            }
            if (!entry && assets) {
                this.debug(`- From Assets`);
                const url = this.getAssetUrl(key, isFetch);
                const response = await assets.fetch(url);
                if (response.ok) {
                    // TODO: consider populating KV with the asset value if faster.
                    // This could be optional as KV writes are $$.
                    // See https://github.com/opennextjs/opennextjs-cloudflare/pull/194#discussion_r1893166026
                    entry = {
                        value: await response.json(),
                        // __BUILD_TIMESTAMP_MS__ is injected by ESBuild.
                        lastModified: globalThis.__BUILD_TIMESTAMP_MS__,
                    };
                }
                if (!kv) {
                    // The cache can not be updated when there is no KV
                    // As we don't want to keep serving stale data for ever,
                    // we pretend the entry is not in cache
                    if (entry?.value &&
                        "kind" in entry.value &&
                        entry.value.kind === "FETCH" &&
                        entry.value.data?.headers?.expires) {
                        const expiresTime = new Date(entry.value.data.headers.expires).getTime();
                        if (!isNaN(expiresTime) && expiresTime <= Date.now()) {
                            this.debug(`found expired entry (expire time: ${entry.value.data.headers.expires})`);
                            return null;
                        }
                    }
                }
            }
            this.debug(entry ? `-> hit` : `-> miss`);
            return { value: entry?.value, lastModified: entry?.lastModified };
        }
        catch {
            throw new RecoverableError(`Failed to get cache [${key}]`);
        }
    }
    async set(key, value, isFetch) {
        const kv = getCloudflareContext().env.NEXT_CACHE_WORKERS_KV;
        if (!kv) {
            throw new IgnorableError(`No KVNamespace`);
        }
        this.debug(`Set ${key}`);
        try {
            const kvKey = this.getKVKey(key, isFetch);
            // Note: We can not set a TTL as we might fallback to assets,
            //       still removing old data (old BUILD_ID) could help avoiding
            //       the cache growing too big.
            await kv.put(kvKey, JSON.stringify({
                value,
                // Note: `Date.now()` returns the time of the last IO rather than the actual time.
                //       See https://developers.cloudflare.com/workers/reference/security-model/
                lastModified: Date.now(),
            }));
        }
        catch {
            throw new RecoverableError(`Failed to set cache [${key}]`);
        }
    }
    async delete(key) {
        const kv = getCloudflareContext().env.NEXT_CACHE_WORKERS_KV;
        if (!kv) {
            throw new IgnorableError(`No KVNamespace`);
        }
        this.debug(`Delete ${key}`);
        try {
            const kvKey = this.getKVKey(key, /* isFetch= */ false);
            // Do not delete the key as we would then fallback to the assets.
            await kv.put(kvKey, JSON.stringify({ status: STATUS_DELETED }));
        }
        catch {
            throw new RecoverableError(`Failed to delete cache [${key}]`);
        }
    }
    getKVKey(key, isFetch) {
        return `${this.getBuildId()}/${key}.${isFetch ? "fetch" : "cache"}`;
    }
    getAssetUrl(key, isFetch) {
        return isFetch
            ? `http://assets.local/${CACHE_ASSET_DIR}/__fetch/${this.getBuildId()}/${key}`
            : `http://assets.local/${CACHE_ASSET_DIR}/${this.getBuildId()}/${key}.cache`;
    }
    debug(...args) {
        if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {
            console.log(`[Cache ${this.name}] `, ...args);
        }
    }
    getBuildId() {
        return process.env.NEXT_BUILD_ID ?? "no-build-id";
    }
}
export default new Cache();
