import type { BuildOptions as ESBuildOptions } from "esbuild";
import type { DefaultOverrideOptions, OpenNextConfig } from "../types/open-next.js";
export type BuildOptions = ReturnType<typeof normalizeOptions>;
export declare function normalizeOptions(config: OpenNextConfig, distDir: string, tempBuildDir: string): {
    appBuildOutputPath: string;
    appPackageJsonPath: string;
    appPath: string;
    appPublicPath: string;
    buildDir: string;
    config: OpenNextConfig;
    debug: boolean;
    minify: boolean;
    monorepoRoot: string;
    nextVersion: string;
    openNextVersion: string;
    openNextDistDir: string;
    outputDir: string;
    packager: "bun" | "npm" | "yarn" | "pnpm";
    tempBuildDir: string;
};
export declare function esbuildSync(esbuildOptions: ESBuildOptions, options: BuildOptions): void;
export declare function esbuildAsync(esbuildOptions: ESBuildOptions, options: BuildOptions): Promise<void>;
/**
 *  Type of the parameter of `traverseFiles` callbacks
 */
export type TraversePath = {
    absolutePath: string;
    relativePath: string;
};
/**
 * Recursively traverse files in a directory and call `callbackFn` when `conditionFn` returns true
 *
 * The callbacks are passed both the absolute and relative (to root) path to files.
 *
 * @param root - Root directory to search
 * @param conditionFn - Called to determine if `callbackFn` should be called.
 * @param callbackFn - Called when `conditionFn` returns true.
 * @param searchingDir - Directory to search (used for recursion)
 */
export declare function traverseFiles(root: string, conditionFn: (paths: TraversePath) => boolean, callbackFn: (paths: TraversePath) => void, searchingDir?: string): void;
/**
 * Recursively delete files.
 *
 * @see `traverseFiles`.
 *
 * @param root Root directory to search.
 * @param conditionFn Predicate used to delete the files.
 */
export declare function removeFiles(root: string, conditionFn: (paths: TraversePath) => boolean): void;
export declare function getHtmlPages(dotNextPath: string): Set<string>;
export declare function getBuildId(options: BuildOptions): string;
export declare function getOpenNextVersion(): string;
export declare function getNextVersion(appPath: string): string;
/**
 * Compare two semver versions.
 *
 * @param v1 - First version. Can be "latest", otherwise it should be a valid semver version in the format of `major.minor.patch`. Usually is the next version from the package.json without canary suffix. If minor or patch are missing, they are considered 0.
 * @param v2 - Second version. Should not be "latest", it should be a valid semver version in the format of `major.minor.patch`. If minor or patch are missing, they are considered 0.
 * @example
 * compareSemver("1.0.0", "1.0.0") // 0
 */
export declare function compareSemver(v1: string, v2: string): number;
export declare function copyOpenNextConfig(inputDir: string, outputDir: string, isEdge?: boolean): void;
export declare function copyEnvFile(appPath: string, packagePath: string, outputPath: string): void;
/**
 * Check we are in a Nextjs app by looking for the Nextjs config file.
 */
export declare function checkRunningInsideNextjsApp(options: BuildOptions): void;
export declare function printNextjsVersion(options: BuildOptions): void;
export declare function printOpenNextVersion(options: BuildOptions): void;
/**
 * Populates the build directory with the compiled configuration files.
 *
 * We need to get the build relative to the cwd to find the compiled config.
 * This is needed for the case where the app is a single-version monorepo
 * and the package.json is in the root of the monorepo where the build is in
 * the app directory, but the compiled config is in the root of the monorepo.
 */
export declare function initOutputDir(options: BuildOptions): void;
/**
 * @returns Whether the edge runtime is used
 */
export declare function isEdgeRuntime(overrides: DefaultOverrideOptions | undefined): Promise<boolean | undefined>;
export declare function getPackagePath(options: BuildOptions): string;
