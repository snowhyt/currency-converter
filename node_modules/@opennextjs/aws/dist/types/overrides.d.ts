import type { Readable } from "node:stream";
import type { Meta } from "./cache";
import type { BaseEventOrResult, BaseOverride, InternalEvent, InternalResult, Origin, ResolvedRoute, StreamCreator, WaitUntil } from "./open-next";
export interface QueueMessage {
    MessageDeduplicationId: string;
    MessageBody: {
        host: string;
        url: string;
    };
    MessageGroupId: string;
}
export interface Queue {
    send(message: QueueMessage): Promise<void>;
    name: string;
}
export type CachedFile = {
    type: "redirect";
    props?: Object;
    meta?: Meta;
} | {
    type: "page";
    html: string;
    json: Object;
    meta?: Meta;
} | {
    type: "app";
    html: string;
    rsc: string;
    meta?: Meta;
} | {
    type: "route";
    body: string;
    meta?: Meta;
};
export type CachedFetchValue = {
    kind: "FETCH";
    data: {
        headers: {
            [k: string]: string;
        };
        body: string;
        url: string;
        status?: number;
        tags?: string[];
    };
    tags?: string[];
};
export type WithLastModified<T> = {
    lastModified?: number;
    value?: T;
};
export type CacheValue<IsFetch extends boolean> = (IsFetch extends true ? CachedFetchValue : CachedFile) & {
    revalidate?: number | false;
};
export type IncrementalCache = {
    get<IsFetch extends boolean = false>(key: string, isFetch?: IsFetch): Promise<WithLastModified<CacheValue<IsFetch>> | null>;
    set<IsFetch extends boolean = false>(key: string, value: CacheValue<IsFetch>, isFetch?: IsFetch): Promise<void>;
    delete(key: string): Promise<void>;
    name: string;
};
type BaseTagCache = {
    name: string;
};
/**
 * On get :
We have to check for every tag (after reading the incremental cache) that they have not been revalidated.

In DynamoDB, this would require 1 GetItem per tag (including internal one), more realistically 1 BatchGetItem per get (In terms of pricing, it would be billed as multiple single GetItem)

On set :
We don't have to do anything here

On revalidateTag for each tag :
We have to update a single entry for this tag

Pros :
- No need to prepopulate DDB
- Very little write

Cons :
- Might be slower on read
- One page request (i.e. GET request) could require to check a lot of tags (And some of them multiple time when used with the fetch cache)
- Almost impossible to do automatic cdn revalidation by itself
*/
export type NextModeTagCache = BaseTagCache & {
    mode: "nextMode";
    hasBeenRevalidated(tags: string[], lastModified?: number): Promise<boolean>;
    writeTags(tags: string[]): Promise<void>;
    getPathsByTags?: (tags: string[]) => Promise<string[]>;
};
/**
 * On get :
We just check for the cache key in the tag cache. If it has been revalidated we just return null, otherwise we continue

On set :
We have to write both the incremental cache and check the tag cache for non existing tag/key combination. For non existing tag/key combination, we have to add them

On revalidateTag for each tag :
We have to update every possible combination for the requested tag

Pros :
- Very fast on read
- Only one query per get (On DynamoDB it's a lot cheaper)
- Can allow for automatic cdn invalidation on revalidateTag

Cons :
- Lots of write on set and revalidateTag
- Needs to be prepopulated at build time to work properly
 */
export type OriginalTagCache = BaseTagCache & {
    mode?: "original";
    getByTag(tag: string): Promise<string[]>;
    getByPath(path: string): Promise<string[]>;
    getLastModified(path: string, lastModified?: number): Promise<number>;
    writeTags(tags: {
        tag: string;
        path: string;
        revalidatedAt?: number;
    }[]): Promise<void>;
};
export type TagCache = NextModeTagCache | OriginalTagCache;
export type WrapperHandler<E extends BaseEventOrResult = InternalEvent, R extends BaseEventOrResult = InternalResult> = (handler: OpenNextHandler<E, R>, converter: Converter<E, R>) => Promise<(...args: any[]) => any>;
export type Wrapper<E extends BaseEventOrResult = InternalEvent, R extends BaseEventOrResult = InternalResult> = BaseOverride & {
    wrapper: WrapperHandler<E, R>;
    supportStreaming: boolean;
    edgeRuntime?: boolean;
};
export type OpenNextHandlerOptions = {
    streamCreator?: StreamCreator;
    waitUntil?: WaitUntil;
};
export type OpenNextHandler<E extends BaseEventOrResult = InternalEvent, R extends BaseEventOrResult = InternalResult> = (event: E, options?: OpenNextHandlerOptions) => Promise<R>;
export type Converter<E extends BaseEventOrResult = InternalEvent, R extends BaseEventOrResult = InternalResult> = BaseOverride & {
    convertFrom: (event: any) => Promise<E>;
    convertTo: (result: R, originalRequest?: any) => Promise<any>;
};
export type Warmer = BaseOverride & {
    invoke: (warmerId: string) => Promise<void>;
};
export type ImageLoader = BaseOverride & {
    load: (url: string) => Promise<{
        body?: Readable;
        contentType?: string;
        cacheControl?: string;
    }>;
};
export type OriginResolver = BaseOverride & {
    resolve: (path: string) => Promise<Origin | false>;
};
export type ProxyExternalRequest = BaseOverride & {
    proxy: (event: InternalEvent) => Promise<InternalResult>;
};
type CDNPath = {
    initialPath: string;
    rawPath: string;
    resolvedRoutes: ResolvedRoute[];
};
export type CDNInvalidationHandler = BaseOverride & {
    invalidatePaths: (paths: CDNPath[]) => Promise<void>;
};
export {};
